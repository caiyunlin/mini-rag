# powershell.md

**文档ID**: 3873c1c5-4410-42fa-9cc3-ed8dd7c0ddb8
**上传时间**: 2025-10-28T13:40:13.576472
**文件大小**: 10189 字符
**分块数量**: 15

---

PowerShell 使用整理
PowerShell 简介

Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。

PowerShell 在线课程

Youtube - PowerShell Master Class

PowerShell 版本区别
版本注意事项
- PowerShell 5.1 只能运行在 Windows 平台上，PowerShell 7.x 则可以运行在 Windows 和 Linux 平台上  
- PowerShell 5.1 和 7.x 可以在 Windows 上同时安装, 5.1 的启动命令是 powershell.exe 而 7.x 启动命令是 pwsh
- Windows 版本 PowerShell 3.0 (Windows6.1-KB2506143-x64.msu) 适用于 Windows 2008 R2 升级 参考此处 点击下载
- Windows 版本 PowerShell 5.1  (Windows Management Framework 5.1) 点击下载
- 跨平台版本 PowerShell 7.2 点击下载
查看 PowerShell 版本
powershell
$host
$host.Version
设置 PowerShell 执行策略
默认PowerShell是不可以直接运行用户自定义的ps1文件的，可以运行下面的命令开启用户脚本执行权限
powershell
Set-ExecutionPolicy ByPass
PowerShell 远程调用
```powershell
$scripts = {
    dir
}
$c = Get-Credential
$server = "remote.server.address"
winrm s winrm/config/client '@{TrustedHosts="$server"}'
Invoke-Command -Script $scripts -Computer $server -Credential $c
```
PowerShell 获得当前脚本路径
在ps1脚本里面执行下面语句，可以得到当前脚本的路径，在PowerShell命令行直接输入无效
powershell
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
PowerShell 获取windows窗口标题
powershell
Get-Process |where {$_.mainWindowTItle} |format-table id,name,mainwindowtitle –AutoSize
PowerShell 添加环境变量
```powershell
$myPath = "C:\work\software\wget"
```
PowerShell 进度条
powershell
for ($I = 1; $I -le 100; $I++ ) {Write-Progress -Activity "Deployment in Progress" -Status "$I% Complete:" -PercentComplete $I;}
PowerShell 数组操作
```powershell
数组可以是不同类型
$myArray = 'Hello', 12, (Get-Date), $null, $true
数组可以用区间快速取值
$myArray = $myArray[0..2]
可以用负数表示从后面开始取值
$latest = $myArray[-1]
```
PowerShell 小数操作
```powershell
四舍五入
直接进位
```
PowerShell 格式化数字/日期
```powershell
数字的补零
'{0:d4}' -f 10 
保留小数位数
'{0:f4}' -f 10
转换为百分比
'{0:p2}' -f 0.4567
转换为十六进制
'{0:x}' -f 255
以大写字母方式转换为十六进制
'{0:X}' -f 255
转换为十六进制并补零
'{0:X8}' -f 255
格式化当前时间，只显示日期
'{0:d}' -f (Get-Date)
'{0:D}' -f (Get-Date)
格式化当前时间，只显示时间
'{0:t}' -f (Get-Date)
'{0:T}' -f (Get-Date)
指定格式输出当前时间，只显示年月日
'{0:yyyy-MM-dd}' -f (Get-Date)
自定义格式化
'当前百分比 {0:p}' -f 0.5
格式化时间戳
$timstamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss fff")
```
PowerShell 下载http/https文件
```powershell
  function Get-File($source,$destination){
    [Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    $wc = New-Object System.Net.WebClient
    $destinationFolder = Split-Path -Parent $destination
    if(!(Test-Path($destinationFolder))){
        md $destinationFolder | Out-Null
    }
    $source = $source.Replace('\','/')
    Write-Host "Downloading File $source"
    $wc.DownloadFile($source,$destination) 
} 
```
PowerShell 忽略SSL证书错误
```powershell
if (-not("dummy" -as [type])) {
    add-type -TypeDefinition @"
using System;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
public static class Dummy {
    public static bool ReturnTrue(object sender,
        X509Certificate certificate,
        X509Chain chain,
        SslPolicyErrors sslPolicyErrors) { return true; }
public static RemoteCertificateValidationCallback GetDelegate() {
    return new RemoteCertificateValidationCallback(Dummy.ReturnTrue);
}

}
"@
}
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = [dummy]::GetDelegate()
Call https
Invoke-RestMethod https://yic3.arrteam.net/
```
PowerShell 制作自签名证书
```powershell
$rootCertName = "MyCA"
$cert = New-SelfSignedCertificate -Type Custom -KeySpec Signature -Subject "CN=$rootCertName" -KeyExportPolicy Exportable
-HashAlgorithm sha256 -KeyLength 2048 -CertStoreLocation "Cert:\CurrentUser\My"
-KeyUsageProperty Sign -KeyUsage CertSign
$domainName = "mydomain.abc.com"
New-SelfSignedCertificate -Type Custom -KeySpec Signature -Subject "CN=$domainName" -KeyExportPolicy Exportable
-HashAlgorithm sha256 -KeyLength 2048 -CertStoreLocation "Cert:\CurrentUser\My"
-Signer $cert -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.2")
```
PowerShell 使用 Authorization

使用 Bearer 认证

powershell
  $token = "xxxxx token"
  $headers = @{
      Authorization = "Bearer $token"
  }
  $url = "target url"
  $responseData = (Invoke-WebRequest -Uri $Url -Method Get -Headers $headers -UseBasicParsing -ContentType "application/json").Content

使用 Basic 认证

powershell
  $user = ''
  $pass = $pat
  $pair = "$($user):$($pass)"
  $encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
  $basicAuthValue = "Basic $encodedCreds"
  $headers = @{
      Authorization = $basicAuthValue
  }
  $url = "target url"
  $responseData = (Invoke-WebRequest -Uri $Url -Method Get -Headers $headers -UseBasicParsing -ContentType "application/json").Content
PowerShell Invoke-RestMethod 示例
Simple GET example
```powershell
$response = Invoke-RestMethod 'http://example.com/api/people'
assuming the response was in this format { "items": [] }
we can now extract the child people like this
$people = $response.items
```
GET with custom headers example
```powershell
$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$headers.Add("X-DATE", '9/29/2014')
$headers.Add("X-SIGNATURE", '234j123l4kl23j41l23k4j')
$headers.Add("X-API-KEY", 'testuser')
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Headers $headers
```
PUT/POST example
powershell
$person = @{
    first='joe'
    lastname='doe'
}
$json = $person | ConvertTo-Json
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Method Put -Body $json -ContentType 'application/json'
DELETE example
powershell
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Method Delete
PowerShell 获取本地账号
```powershell
$adsi = [ADSI]"WinNT://$env:COMPUTERNAME"
$users = $adsi.Children | where {$_.SchemaClassName -eq 'user'}
```
PowerShell 添加本地账号
```powershell
create user
$newUser = 'testUser'
$newPassword = 'pwd@WSXcde#$RFV'
$conn = [ADSI]"WinNT://."
$cUser = $conn.Create("user", $newUser)
$cUser.put("UserFlags", 64 + 65536)
$cUser.SetPassword($newPassword)
$cUser.SetInfo()
Add to Administrators group
$group = "Administrators"
$computerName = $env:computername
$groupObj = [ADSI]"WinNT://./$group,group"
$userObj = [ADSI]"WinNT://$computerName/$newUser,user"
$groupObj.Add($userObj.Path)
```
PowerShell 设置环境变量
```powershell
```
PowerShell 获取其他程序输出
powershell
$result = (echo "abcde")
PowerShell 修改注册表
$key = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced'
Set-ItemProperty $key Hidden 1
Set-ItemProperty $key HideFileExt 0
Set-ItemProperty $key ShowSuperHidden 1
PowerShell 操作IIS Web Site
https://www.cnblogs.com/lmfeng/p/10763547.html
PowerShell 写二进制文件
```powershell
$scriptPath = $PSScriptRoot
$sourceFile = "$scriptPath\source.bin"
$bytes = [System.IO.File]::ReadAllBytes($sourceFile)
$filePath = "$scriptPath\target.dat"
$stream = New-Object System.IO.FileStream $filePath, 'Open','Write','Read'
从文件头部开始写，如果需要在后面添加，就把上面参数 'Open' 换成 'Append'
参考 https://www.geeksforgeeks.org/basics-of-filestream-in-c-sharp/
foreach($byte in $bytes){
    $stream.WriteByte($byte)
}
$stream.Close()
```
Powershell 调用 .NET
调用静态方法
```powershell
```
列出所有静态方法
powershell
[System.Diagnostics.Process] | gm -Static
调用实例方法
```powershell
无参数
$xmlDoc = new-object System.Xml.XmlDocument
$xmlDoc.Load($file)
带参数
$stream = New-Object System.IO.FileStream $filePath, 'Open','Write','Read'
```
列出实例方法
powershell
$xmlDoc = new-object System.Xml.XmlDocument
$xmlDoc | gm
加载 Assembly
```powershell
加载Assembly文件
或者 使用下面方法，防止Assembly被Lock
$bytes = [System.IO.File]::ReadAllBytes($storageAssemblyPath)
直接加载GAC
Add-Type -AssemblyName "Microsoft.ServiceBus, Version=2.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
```
查看当前PowerShell支持加载的.NET集合
```powershell
```
PowerShell 操作XML
powershell
$xml = [xml] (Get-Content '.\file.xml')
$node = $xml.SelectSingleNode('xpath')
$node.myproperty = 'abc'
PowerShell 验证AD密码是否正确
```powershell
Add-Type -AssemblyName System.DirectoryServices.AccountManagement 
$DS = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine)
$UserName = 'domain\username'
$Password = 'password'
$Result = $DS.ValidateCredentials($UserName, $Password) 
```
PowerShell 数据库操作
获取表数据
```powershell
$conn = "Server=DBServer;Database=TestDB;Uid=sa;Pwd=sa;"
$conn = "Server=DBServer;Database=TestDB;Trusted_Connection=yes;"
function ExecuteSqlQuery ($conn, $sql) {
    $Datatable = New-Object System.Data.DataTable
    $Connection = New-Object System.Data.SQLClient.SQLConnection
    $Connection.ConnectionString = $conn
    $Connection.Open()
$Command = New-Object System.Data.SQLClient.SQLCommand
$Command.Connection = $Connection
$Command.CommandText = $sql
$Reader = $Command.ExecuteReader()
$Datatable.Load($Reader)

$Connection.Close()
return $Datatable

}
```
执行SQL语句
```powershell
function ExecuteSqlNonQuery($conn, $sql){
    $Connection = New-Object System.Data.SQLClient.SQLConnection
    $Connection.ConnectionString = $conn
    $Connection.Open()
$Command = New-Object System.Data.SQLClient.SQLCommand
$Command.Connection = $Connection
$Command.CommandText = $sql
$Command.ExecuteNonQuery() | Out-Null

$Connection.Close()

}
```
PowerShell 模拟键盘输入
使用SendWait函数，具体按键信息参考  https://msdn.microsoft.com/it-it/library/system.windows.forms.sendkeys(v=VS.100).aspx
```powershell
Add-Type -AssemblyName System.Windows.Forms
```
PowerShell 默认压缩解压
```powershell
压缩
$compress = @{
  Path = "C:\Reference\Draftdoc.docx", "C:\Reference\Images*.vsd"
  CompressionLevel = "Fastest"
  DestinationPath = "C:\Archives\Draft.Zip"
}
Compress-Archive @compress
解压，会自动创建目标文件夹，使用 -Force 可以强制覆盖
Expand-Archive -LiteralPath 'C:\Archives\Draft[v1].Zip' -DestinationPath C:\Reference -Force
```
PowerShell 发送信息到 Teams
https://learn.microsoft.com/en-us/archive/blogs/stefan_stranger/use-webhook-connector-to-send-data-from-powershell-to-microsoft-teams
PowerShell 分析 Markdown
```powershell
Install-Module -Name platyPS -Scope CurrentUser
Import-Module platyPS
Get-MarkdownMetadata -Path c:\temp.md
```
PowerShell 生成符号链接
```powershell
注意 : -Path 是需要生成的文件，而 -Target 是原来的已经存在的文件
New-Item -ItemType SymbolicLink -Path link.txt -Target target.txt
删除符号链接，直接删除文件即可
Remove-Item link.txt
```

---

## 文档分块

### 分块 1

PowerShell 使用整理
PowerShell 简介

Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。

PowerShell 在线课程

Youtube - PowerShell Master Class

PowerShell 版本区别
版本注意事项
- PowerShell 5.1 只能运行在 Windows 平台上，PowerShell 7.x 则可以运行在 Windows 和 Linux 平台上  
- PowerShell 5.1 和 7.x 可以在 Windows 上同时安装, 5.1 的启动命令是 powershell.exe 而 7.x 启动命令是 pwsh
- Windows 版本 PowerShell 3.0 (Windows6.1-KB2506143-x64.msu) 适用于 Windows 2008 R2 升级 参考此处 点击下载
- Windows 版本 PowerShell 5.1  (Windows Management Framework 5.1) 点击下载
- 跨平台版本 PowerShell 7.2 点击下载
查看 PowerShell 版本
powershell
$host
$host.Version
设置 PowerShell 执行策略
默认PowerShell是不可以直接运行用户自定义的ps1文件的，可以运行下面的命令开启用户脚本执行权限
powershell
Set-ExecutionPolicy ByPass
PowerShell 远程调用
```powershell
$scripts = {
    dir
}
$c = Get-Credential
$server = "remote.server.

---

### 分块 2

Shell 执行策略
默认PowerShell是不可以直接运行用户自定义的ps1文件的，可以运行下面的命令开启用户脚本执行权限
powershell
Set-ExecutionPolicy ByPass
PowerShell 远程调用
```powershell
$scripts = {
    dir
}
$c = Get-Credential
$server = "remote.server.address"
winrm s winrm/config/client '@{TrustedHosts="$server"}'
Invoke-Command -Script $scripts -Computer $server -Credential $c
```
PowerShell 获得当前脚本路径
在ps1脚本里面执行下面语句，可以得到当前脚本的路径，在PowerShell命令行直接输入无效
powershell
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
PowerShell 获取windows窗口标题
powershell
Get-Process |where {$_.mainWindowTItle} |format-table id,name,mainwindowtitle –AutoSize
PowerShell 添加环境变量
```powershell
$myPath = "C:\work\software\wget"
```
PowerShell 进度条
powershell
for ($I = 1; $I -le 100; $I++ ) {Write-Progress -Activity "Deployment in Progress" -Status "$I% Complete:" -PercentComplete $I;}
PowerShell 数组操作
```powershell
数组可以是不同类型
$myArray = 'Hello', 12, (Get-Date), $null, $true
数组可以用区间快速取值
$myArray = $myArray[0..

---

### 分块 3

vity "Deployment in Progress" -Status "$I% Complete:" -PercentComplete $I;}
PowerShell 数组操作
```powershell
数组可以是不同类型
$myArray = 'Hello', 12, (Get-Date), $null, $true
数组可以用区间快速取值
$myArray = $myArray[0..2]
可以用负数表示从后面开始取值
$latest = $myArray[-1]
```
PowerShell 小数操作
```powershell
四舍五入
直接进位
```
PowerShell 格式化数字/日期
```powershell
数字的补零
'{0:d4}' -f 10 
保留小数位数
'{0:f4}' -f 10
转换为百分比
'{0:p2}' -f 0.4567
转换为十六进制
'{0:x}' -f 255
以大写字母方式转换为十六进制
'{0:X}' -f 255
转换为十六进制并补零
'{0:X8}' -f 255
格式化当前时间，只显示日期
'{0:d}' -f (Get-Date)
'{0:D}' -f (Get-Date)
格式化当前时间，只显示时间
'{0:t}' -f (Get-Date)
'{0:T}' -f (Get-Date)
指定格式输出当前时间，只显示年月日
'{0:yyyy-MM-dd}' -f (Get-Date)
自定义格式化
'当前百分比 {0:p}' -f 0.5
格式化时间戳
$timstamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss fff")
```
PowerShell 下载http/https文件
```powershell
  function Get-File($source,$destination){
    [Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
    [Net.ServicePointManager]::SecurityProtocol = [Net.

---

### 分块 4

tp/https文件
```powershell
  function Get-File($source,$destination){
    [Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    $wc = New-Object System.Net.WebClient
    $destinationFolder = Split-Path -Parent $destination
    if(!(Test-Path($destinationFolder))){
        md $destinationFolder | Out-Null
    }
    $source = $source.Replace('\','/')
    Write-Host "Downloading File $source"
    $wc.DownloadFile($source,$destination) 
} 
```
PowerShell 忽略SSL证书错误
```powershell
if (-not("dummy" -as [type])) {
    add-type -TypeDefinition @"
using System;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.

---

### 分块 5

} 
```
PowerShell 忽略SSL证书错误
```powershell
if (-not("dummy" -as [type])) {
    add-type -TypeDefinition @"
using System;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
public static class Dummy {
    public static bool ReturnTrue(object sender,
        X509Certificate certificate,
        X509Chain chain,
        SslPolicyErrors sslPolicyErrors) { return true; }
public static RemoteCertificateValidationCallback GetDelegate() {
    return new RemoteCertificateValidationCallback(Dummy.ReturnTrue);
}

}
"@
}
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = [dummy]::GetDelegate()
Call https
Invoke-RestMethod https://yic3.arrteam.

---

### 分块 6

ificateValidationCallback(Dummy.ReturnTrue);
}

}
"@
}
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = [dummy]::GetDelegate()
Call https
Invoke-RestMethod https://yic3.arrteam.net/
```
PowerShell 制作自签名证书
```powershell
$rootCertName = "MyCA"
$cert = New-SelfSignedCertificate -Type Custom -KeySpec Signature -Subject "CN=$rootCertName" -KeyExportPolicy Exportable
-HashAlgorithm sha256 -KeyLength 2048 -CertStoreLocation "Cert:\CurrentUser\My"
-KeyUsageProperty Sign -KeyUsage CertSign
$domainName = "mydomain.abc.com"
New-SelfSignedCertificate -Type Custom -KeySpec Signature -Subject "CN=$domainName" -KeyExportPolicy Exportable
-HashAlgorithm sha256 -KeyLength 2048 -CertStoreLocation "Cert:\CurrentUser\My"
-Signer $cert -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.

---

### 分块 7

e -Subject "CN=$domainName" -KeyExportPolicy Exportable
-HashAlgorithm sha256 -KeyLength 2048 -CertStoreLocation "Cert:\CurrentUser\My"
-Signer $cert -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.2")
```
PowerShell 使用 Authorization

使用 Bearer 认证

powershell
  $token = "xxxxx token"
  $headers = @{
      Authorization = "Bearer $token"
  }
  $url = "target url"
  $responseData = (Invoke-WebRequest -Uri $Url -Method Get -Headers $headers -UseBasicParsing -ContentType "application/json").Content

使用 Basic 认证

powershell
  $user = ''
  $pass = $pat
  $pair = "$($user):$($pass)"
  $encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
  $basicAuthValue = "Basic $encodedCreds"
  $headers = @{
      Authorization = $basicAuthValue
  }
  $url = "target url"
  $responseData = (Invoke-WebRequest -Uri $Url -Method Get -Headers $headers -UseBasicParsing -ContentType "application/json").

---

### 分块 8

ers = @{
      Authorization = $basicAuthValue
  }
  $url = "target url"
  $responseData = (Invoke-WebRequest -Uri $Url -Method Get -Headers $headers -UseBasicParsing -ContentType "application/json").Content
PowerShell Invoke-RestMethod 示例
Simple GET example
```powershell
$response = Invoke-RestMethod 'http://example.com/api/people'
assuming the response was in this format { "items": [] }
we can now extract the child people like this
$people = $response.items
```
GET with custom headers example
```powershell
$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$headers.Add("X-DATE", '9/29/2014')
$headers.Add("X-SIGNATURE", '234j123l4kl23j41l23k4j')
$headers.Add("X-API-KEY", 'testuser')
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Headers $headers
```
PUT/POST example
powershell
$person = @{
    first='joe'
    lastname='doe'
}
$json = $person | ConvertTo-Json
$response = Invoke-RestMethod 'http://example.

---

### 分块 9

le.com/api/people/1' -Headers $headers
```
PUT/POST example
powershell
$person = @{
    first='joe'
    lastname='doe'
}
$json = $person | ConvertTo-Json
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Method Put -Body $json -ContentType 'application/json'
DELETE example
powershell
$response = Invoke-RestMethod 'http://example.com/api/people/1' -Method Delete
PowerShell 获取本地账号
```powershell
$adsi = [ADSI]"WinNT://$env:COMPUTERNAME"
$users = $adsi.Children | where {$_.SchemaClassName -eq 'user'}
```
PowerShell 添加本地账号
```powershell
create user
$newUser = 'testUser'
$newPassword = 'pwd@WSXcde#$RFV'
$conn = [ADSI]"WinNT://."
$cUser = $conn.Create("user", $newUser)
$cUser.put("UserFlags", 64 + 65536)
$cUser.SetPassword($newPassword)
$cUser.SetInfo()
Add to Administrators group
$group = "Administrators"
$computerName = $env:computername
$groupObj = [ADSI]"WinNT://./$group,group"
$userObj = [ADSI]"WinNT://$computerName/$newUser,user"
$groupObj.Add($userObj.

---

### 分块 10

ministrators group
$group = "Administrators"
$computerName = $env:computername
$groupObj = [ADSI]"WinNT://./$group,group"
$userObj = [ADSI]"WinNT://$computerName/$newUser,user"
$groupObj.Add($userObj.Path)
```
PowerShell 设置环境变量
```powershell
```
PowerShell 获取其他程序输出
powershell
$result = (echo "abcde")
PowerShell 修改注册表
$key = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced'
Set-ItemProperty $key Hidden 1
Set-ItemProperty $key HideFileExt 0
Set-ItemProperty $key ShowSuperHidden 1
PowerShell 操作IIS Web Site
https://www.cnblogs.com/lmfeng/p/10763547.html
PowerShell 写二进制文件
```powershell
$scriptPath = $PSScriptRoot
$sourceFile = "$scriptPath\source.bin"
$bytes = [System.IO.File]::ReadAllBytes($sourceFile)
$filePath = "$scriptPath\target.dat"
$stream = New-Object System.IO.FileStream $filePath, 'Open','Write','Read'
从文件头部开始写，如果需要在后面添加，就把上面参数 'Open' 换成 'Append'
参考 https://www.geeksforgeeks.org/basics-of-filestream-in-c-sharp/
foreach($byte in $bytes){
    $stream.

---

### 分块 11

tem.IO.FileStream $filePath, 'Open','Write','Read'
从文件头部开始写，如果需要在后面添加，就把上面参数 'Open' 换成 'Append'
参考 https://www.geeksforgeeks.org/basics-of-filestream-in-c-sharp/
foreach($byte in $bytes){
    $stream.WriteByte($byte)
}
$stream.Close()
```
Powershell 调用 .NET
调用静态方法
```powershell
```
列出所有静态方法
powershell
[System.Diagnostics.Process] | gm -Static
调用实例方法
```powershell
无参数
$xmlDoc = new-object System.Xml.XmlDocument
$xmlDoc.Load($file)
带参数
$stream = New-Object System.IO.FileStream $filePath, 'Open','Write','Read'
```
列出实例方法
powershell
$xmlDoc = new-object System.Xml.XmlDocument
$xmlDoc | gm
加载 Assembly
```powershell
加载Assembly文件
或者 使用下面方法，防止Assembly被Lock
$bytes = [System.IO.File]::ReadAllBytes($storageAssemblyPath)
直接加载GAC
Add-Type -AssemblyName "Microsoft.ServiceBus, Version=2.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
```
查看当前PowerShell支持加载的.NET集合
```powershell
```
PowerShell 操作XML
powershell
$xml = [xml] (Get-Content '.\file.xml')
$node = $xml.

---

### 分块 12

us, Version=2.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
```
查看当前PowerShell支持加载的.NET集合
```powershell
```
PowerShell 操作XML
powershell
$xml = [xml] (Get-Content '.\file.xml')
$node = $xml.SelectSingleNode('xpath')
$node.myproperty = 'abc'
PowerShell 验证AD密码是否正确
```powershell
Add-Type -AssemblyName System.DirectoryServices.AccountManagement 
$DS = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine)
$UserName = 'domain\username'
$Password = 'password'
$Result = $DS.ValidateCredentials($UserName, $Password) 
```
PowerShell 数据库操作
获取表数据
```powershell
$conn = "Server=DBServer;Database=TestDB;Uid=sa;Pwd=sa;"
$conn = "Server=DBServer;Database=TestDB;Trusted_Connection=yes;"
function ExecuteSqlQuery ($conn, $sql) {
    $Datatable = New-Object System.Data.DataTable
    $Connection = New-Object System.Data.SQLClient.SQLConnection
    $Connection.ConnectionString = $conn
    $Connection.

---

### 分块 13

uteSqlQuery ($conn, $sql) {
    $Datatable = New-Object System.Data.DataTable
    $Connection = New-Object System.Data.SQLClient.SQLConnection
    $Connection.ConnectionString = $conn
    $Connection.Open()
$Command = New-Object System.Data.SQLClient.SQLCommand
$Command.Connection = $Connection
$Command.CommandText = $sql
$Reader = $Command.ExecuteReader()
$Datatable.Load($Reader)

$Connection.Close()
return $Datatable

}
```
执行SQL语句
```powershell
function ExecuteSqlNonQuery($conn, $sql){
    $Connection = New-Object System.Data.SQLClient.SQLConnection
    $Connection.ConnectionString = $conn
    $Connection.Open()
$Command = New-Object System.Data.SQLClient.SQLCommand
$Command.Connection = $Connection
$Command.CommandText = $sql
$Command.ExecuteNonQuery() | Out-Null

$Connection.Close()

}
```
PowerShell 模拟键盘输入
使用SendWait函数，具体按键信息参考  https://msdn.microsoft.com/it-it/library/system.windows.forms.sendkeys(v=VS.100).aspx
```powershell
Add-Type -AssemblyName System.Windows.

---

### 分块 14

ction.Close()

}
```
PowerShell 模拟键盘输入
使用SendWait函数，具体按键信息参考  https://msdn.microsoft.com/it-it/library/system.windows.forms.sendkeys(v=VS.100).aspx
```powershell
Add-Type -AssemblyName System.Windows.Forms
```
PowerShell 默认压缩解压
```powershell
压缩
$compress = @{
  Path = "C:\Reference\Draftdoc.docx", "C:\Reference\Images*.vsd"
  CompressionLevel = "Fastest"
  DestinationPath = "C:\Archives\Draft.Zip"
}
Compress-Archive @compress
解压，会自动创建目标文件夹，使用 -Force 可以强制覆盖
Expand-Archive -LiteralPath 'C:\Archives\Draft[v1].Zip' -DestinationPath C:\Reference -Force
```
PowerShell 发送信息到 Teams
https://learn.microsoft.com/en-us/archive/blogs/stefan_stranger/use-webhook-connector-to-send-data-from-powershell-to-microsoft-teams
PowerShell 分析 Markdown
```powershell
Install-Module -Name platyPS -Scope CurrentUser
Import-Module platyPS
Get-MarkdownMetadata -Path c:\temp.md
```
PowerShell 生成符号链接
```powershell
注意 : -Path 是需要生成的文件，而 -Target 是原来的已经存在的文件
New-Item -ItemType SymbolicLink -Path link.txt -Target target.

---

### 分块 15

Import-Module platyPS
Get-MarkdownMetadata -Path c:\temp.md
```
PowerShell 生成符号链接
```powershell
注意 : -Path 是需要生成的文件，而 -Target 是原来的已经存在的文件
New-Item -ItemType SymbolicLink -Path link.txt -Target target.txt
删除符号链接，直接删除文件即可
Remove-Item link.txt
```

---

